package persistence

import (
    "context"
    "database/sql"
    "errors"
    "fmt"
    "time"

    "github.com/google/uuid"
    "github.com/jmoiron/sqlx"

    domainSession "{{ .ModulePath }}/internal/domain/session"
    domainUser "{{ .ModulePath }}/internal/domain/user"
)

type SQLiteUserRepository struct {
    db *sqlx.DB
}

func NewSQLiteUserRepository(db *sqlx.DB) *SQLiteUserRepository {
    return &SQLiteUserRepository{db: db}
}

func (r *SQLiteUserRepository) FindByID(ctx context.Context, id string) (*domainUser.User, error) {
    return fetchUser(ctx, r.db, `SELECT id, email, name, avatar_url, created_at FROM users WHERE id = ?`, id)
}

func (r *SQLiteUserRepository) FindByIdentity(ctx context.Context, provider, subject string) (*domainUser.User, error) {
    const query = `SELECT u.id, u.email, u.name, u.avatar_url, u.created_at
FROM users u
INNER JOIN user_identities ui ON ui.user_id = u.id
WHERE ui.provider = ? AND ui.subject = ?`
    return fetchUser(ctx, r.db, query, provider, subject)
}

func (r *SQLiteUserRepository) Create(ctx context.Context, u *domainUser.User) error {
    return insertUser(ctx, r.db, u)
}

func (r *SQLiteUserRepository) Update(ctx context.Context, u *domainUser.User) error {
    return updateUser(ctx, r.db, u)
}

func (r *SQLiteUserRepository) AttachIdentity(ctx context.Context, userID, provider, subject string) error {
    return insertIdentity(ctx, r.db, userID, provider, subject)
}

func (r *SQLiteUserRepository) EnsureUserWithIdentityAndCreateSession(
    ctx context.Context,
    candidate *domainUser.User,
    provider, subject string,
    sess *domainSession.Session,
) (*domainUser.User, *domainSession.Session, error) {
    if candidate == nil {
        return nil, nil, fmt.Errorf("candidate user is required")
    }
    if sess == nil {
        return nil, nil, fmt.Errorf("session is required")
    }
    if provider == "" {
        return nil, nil, fmt.Errorf("provider is required")
    }
    if subject == "" {
        return nil, nil, fmt.Errorf("subject is required")
    }

    var ensuredUser *domainUser.User
    var ensuredSession *domainSession.Session
    err := runInTx(ctx, r.db, func(tx *sqlx.Tx) error {
        userRepo := newTxUserRepository(tx)
        sessionRepo := newTxSessionRepository(tx)

        existing, err := userRepo.FindByIdentity(ctx, provider, subject)
        if err != nil {
            return fmt.Errorf("find user: %w", err)
        }

        if existing == nil {
            if err := userRepo.Create(ctx, candidate); err != nil {
                return fmt.Errorf("create user: %w", err)
            }
            if err := userRepo.AttachIdentity(ctx, candidate.ID, provider, subject); err != nil {
                return fmt.Errorf("attach identity: %w", err)
            }
            ensuredUser = candidate
        } else {
            ensuredUser = existing
            updated := false
            if candidate.Name != "" && ensuredUser.Name != candidate.Name {
                ensuredUser.Name = candidate.Name
                updated = true
            }
            if candidate.Email != "" && ensuredUser.Email != candidate.Email {
                ensuredUser.Email = candidate.Email
                updated = true
            }
            if candidate.AvatarURL != "" && ensuredUser.AvatarURL != candidate.AvatarURL {
                ensuredUser.AvatarURL = candidate.AvatarURL
                updated = true
            }
            if updated {
                if err := userRepo.Update(ctx, ensuredUser); err != nil {
                    return fmt.Errorf("update user: %w", err)
                }
            }
        }

        sess.UserID = ensuredUser.ID
        if err := sessionRepo.Create(ctx, sess); err != nil {
            return fmt.Errorf("create session: %w", err)
        }
        ensuredSession = sess
        return nil
    })
    if err != nil {
        return nil, nil, err
    }

    return ensuredUser, ensuredSession, nil
}

type txUserRepository struct {
    tx *sqlx.Tx
}

func newTxUserRepository(tx *sqlx.Tx) *txUserRepository { return &txUserRepository{tx: tx} }

func (r *txUserRepository) FindByID(ctx context.Context, id string) (*domainUser.User, error) {
    return fetchUser(ctx, r.tx, `SELECT id, email, name, avatar_url, created_at FROM users WHERE id = ?`, id)
}

func (r *txUserRepository) FindByIdentity(ctx context.Context, provider, subject string) (*domainUser.User, error) {
    const query = `SELECT u.id, u.email, u.name, u.avatar_url, u.created_at
FROM users u
INNER JOIN user_identities ui ON ui.user_id = u.id
WHERE ui.provider = ? AND ui.subject = ?`
    return fetchUser(ctx, r.tx, query, provider, subject)
}

func (r *txUserRepository) Create(ctx context.Context, u *domainUser.User) error {
    return insertUser(ctx, r.tx, u)
}

func (r *txUserRepository) Update(ctx context.Context, u *domainUser.User) error {
    return updateUser(ctx, r.tx, u)
}

func (r *txUserRepository) AttachIdentity(ctx context.Context, userID, provider, subject string) error {
    return insertIdentity(ctx, r.tx, userID, provider, subject)
}

type dbUser struct {
    ID        string    `db:"id"`
    Email     string    `db:"email"`
    Name      string    `db:"name"`
    AvatarURL string    `db:"avatar_url"`
    CreatedAt time.Time `db:"created_at"`
}

func (u dbUser) toDomain() *domainUser.User {
    return &domainUser.User{
        ID:        u.ID,
        Email:     u.Email,
        Name:      u.Name,
        AvatarURL: u.AvatarURL,
        CreatedAt: u.CreatedAt,
    }
}

func fetchUser(ctx context.Context, q sqlx.QueryerContext, query string, args ...any) (*domainUser.User, error) {
    var row dbUser
    if err := sqlx.GetContext(ctx, q, &row, query, args...); err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, nil
        }
        return nil, err
    }
    return row.toDomain(), nil
}

func insertUser(ctx context.Context, exec sqlx.ExecerContext, u *domainUser.User) error {
    _, err := exec.ExecContext(ctx, `INSERT INTO users(id, email, name, avatar_url, created_at) VALUES(?, ?, ?, ?, ?)`,
        u.ID, u.Email, u.Name, u.AvatarURL, u.CreatedAt)
    return err
}

func updateUser(ctx context.Context, exec sqlx.ExecerContext, u *domainUser.User) error {
    _, err := exec.ExecContext(ctx, `UPDATE users SET email = ?, name = ?, avatar_url = ? WHERE id = ?`,
        u.Email, u.Name, u.AvatarURL, u.ID)
    return err
}

func insertIdentity(ctx context.Context, exec sqlx.ExecerContext, userID, provider, subject string) error {
    uid, err := uuid.NewV7()
    if err != nil {
        return err
    }
    _, err = exec.ExecContext(ctx, `INSERT INTO user_identities(id, user_id, provider, subject, created_at) VALUES(?, ?, ?, ?, ?)`,
        uid.String(), userID, provider, subject, time.Now().UTC())
    return err
}
