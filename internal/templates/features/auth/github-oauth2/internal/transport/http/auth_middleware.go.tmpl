package http

import (
	"context"
	"net/http"
	"net/url"

	appauth "{{ .ModulePath }}/internal/app/auth"
)

type ctxKey string

const userKey ctxKey = "currentUser"

func withUser(ctx context.Context, user interface{}) context.Context { return context.WithValue(ctx, userKey, user) }
func UserFromContext(ctx context.Context) interface{} { return ctx.Value(userKey) }

// AuthMiddleware resolves the current user from session cookie and injects into context.
func (r *Router) AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		if r.authService == nil { next.ServeHTTP(w, req); return }
		sid := ReadCookie(req, SessionCookieName())
		if sid == "" { next.ServeHTTP(w, req); return }
		resp, _ := r.authService.CurrentUser(req.Context(), appauth.CurrentUserRequest{SessionID: sid})
		if resp.User == nil { next.ServeHTTP(w, req); return }
		next.ServeHTTP(w, req.WithContext(withUser(req.Context(), resp.User)))
	})
}

// RequireAuth enforces authentication and redirects unauthenticated requests to the login page.
func (r *Router) RequireAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		if r.authService == nil {
			http.Error(w, "auth not configured", http.StatusServiceUnavailable)
			return
		}
		sid := ReadCookie(req, SessionCookieName())
		resp, _ := r.authService.CurrentUser(req.Context(), appauth.CurrentUserRequest{SessionID: sid})
		if resp.User == nil {
			q := url.Values{}
			q.Set("next", req.URL.RequestURI())
			http.Redirect(w, req, "/login?"+q.Encode(), http.StatusFound)
			return
		}
		next.ServeHTTP(w, req.WithContext(withUser(req.Context(), resp.User)))
	})
}
