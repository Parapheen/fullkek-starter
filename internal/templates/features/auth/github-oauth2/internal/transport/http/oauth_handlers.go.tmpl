package http

import (
    "fmt"
    "net/http"
    "net/url"
    "path/filepath"
    "strings"
    "unicode"

    appauth "{{ .ModulePath }}/internal/app/auth"
)

// authStart begins the OAuth flow for the requested provider.
func (r *Router) authStart(w http.ResponseWriter, req *http.Request) {
    if r.authService == nil {
        http.Error(w, "auth not configured", http.StatusServiceUnavailable)
        return
    }
    provider := providerFromRequest(req)
    if provider == "" {
        http.NotFound(w, req)
        return
    }
    next := req.URL.Query().Get("next")
    if !isSafeNext(next) {
        next = ""
    }
    resp, err := r.authService.StartOAuth(req.Context(), appauth.StartOAuthRequest{Provider: provider})
    if err != nil || resp.State == "" || resp.RedirectURL == "" {
        http.Error(w, "oauth provider unavailable", http.StatusBadRequest)
        return
    }
    http.SetCookie(w, &http.Cookie{
        Name:     "oauth_state",
        Value:    resp.State,
        Path:     "/",
        HttpOnly: true,
        SameSite: http.SameSiteLaxMode,
        MaxAge:   300, // 5 minutes
    })
    http.SetCookie(w, &http.Cookie{
        Name:     "oauth_next",
        Value:    url.QueryEscape(next),
        Path:     "/",
        HttpOnly: true,
        SameSite: http.SameSiteLaxMode,
        MaxAge:   300,
    })
    http.Redirect(w, req, resp.RedirectURL, http.StatusFound)
}

// authCallback completes the OAuth flow and stores the user in a server-side session.
func (r *Router) authCallback(w http.ResponseWriter, req *http.Request) {
    if r.authService == nil {
        http.Error(w, "auth not configured", http.StatusServiceUnavailable)
        return
    }
    provider := providerFromRequest(req)
    if provider == "" {
        http.NotFound(w, req)
        return
    }
    code := req.URL.Query().Get("code")
    state := req.URL.Query().Get("state")
    cookieState := ReadCookie(req, "oauth_state")
    ua := req.Header.Get("User-Agent")
    ip := req.RemoteAddr

    resp, err := r.authService.HandleCallback(req.Context(), appauth.HandleCallbackRequest{
        Provider:    provider,
        Code:        code,
        State:       state,
        CookieState: cookieState,
        UserAgent:   ua,
        ClientIP:    ip,
    })
    if err != nil {
        http.Error(w, fmt.Sprintf("auth error: %v", err), http.StatusUnauthorized)
        return
    }
    if resp.Session == nil {
        http.Error(w, "auth error: session not created", http.StatusUnauthorized)
        return
    }
    SetCookie(w, SessionCookieName(), resp.Session.ID, resp.Session.ExpiresAt)
    next := ReadCookie(req, "oauth_next")
    if next != "" {
        if decoded, err := url.QueryUnescape(next); err == nil {
            next = decoded
        }
    }
    http.SetCookie(w, &http.Cookie{Name: "oauth_next", Value: "", Path: "/", MaxAge: -1})
    dest := "/profile"
    if isSafeNext(next) {
        dest = next
    }
    http.Redirect(w, req, dest, http.StatusFound)
    _ = resp.User
}

// login renders the login page listing all configured providers.
func (r *Router) login(w http.ResponseWriter, req *http.Request) {
    if r.authService == nil {
        http.Error(w, "auth not configured", http.StatusServiceUnavailable)
        return
    }
    next := req.URL.Query().Get("next")
    if !isSafeNext(next) {
        next = ""
    }
    nextQuery := ""
    if next != "" {
        nextQuery = "?next=" + url.QueryEscape(next)
    }
    providers := r.authService.ProviderIDs()
    type providerOption struct {
        ID    string
        Label string
    }
    formatLabel := func(id string) string {
        cleaned := strings.ReplaceAll(id, "-", " ")
        cleaned = strings.ReplaceAll(cleaned, "_", " ")
        fields := strings.Fields(cleaned)
        if len(fields) == 0 {
            return id
        }
        for i, field := range fields {
            lower := strings.ToLower(field)
            runes := []rune(lower)
            if len(runes) == 0 {
                continue
            }
            runes[0] = unicode.ToUpper(runes[0])
            fields[i] = string(runes)
        }
        return strings.Join(fields, " ")
    }
    opts := make([]providerOption, 0, len(providers.IDs))
    for _, id := range providers.IDs {
        opts = append(opts, providerOption{ID: id, Label: formatLabel(id)})
    }
    data := struct {
        Next      string
        NextQuery string
        Providers []providerOption
    }{
        Next:      next,
        NextQuery: nextQuery,
        Providers: opts,
    }
    if err := renderTemplate(w, filepath.Join("web", "templates", "pages", "login.html"), data); err != nil {
        http.Error(w, fmt.Sprintf("render error: %v", err), http.StatusInternalServerError)
        return
    }
}

// profile renders a protected page with basic user info.
func (r *Router) profile(w http.ResponseWriter, req *http.Request) {
    if r.authService == nil {
        http.Error(w, "auth not configured", http.StatusServiceUnavailable)
        return
    }
    sid := ReadCookie(req, SessionCookieName())
    current, _ := r.authService.CurrentUser(req.Context(), appauth.CurrentUserRequest{SessionID: sid})
    if current.User == nil {
        http.Redirect(w, req, r.signInPath(), http.StatusFound)
        return
    }

    data := struct {
        Name      string
        Email     string
        AvatarURL string
        ID        string
    }{
        Name:      current.User.Name,
        Email:     current.User.Email,
        AvatarURL: current.User.AvatarURL,
        ID:        current.User.ID,
    }

    if err := renderTemplate(w, filepath.Join("web", "templates", "pages", "profile.html"), data); err != nil {
        http.Error(w, fmt.Sprintf("render error: %v", err), http.StatusInternalServerError)
        return
    }
}

// logout clears the session.
func (r *Router) logout(w http.ResponseWriter, req *http.Request) {
    sid := ReadCookie(req, SessionCookieName())
    if r.authService != nil {
        _, _ = r.authService.Logout(req.Context(), appauth.LogoutRequest{SessionID: sid})
    }
    ClearCookie(w, SessionCookieName())
    http.Redirect(w, req, "/", http.StatusFound)
}

func providerFromRequest(req *http.Request) string {
    path := strings.Trim(req.URL.Path, "/")
    parts := strings.Split(path, "/")
    if len(parts) < 2 {
        return ""
    }
    if parts[0] != "auth" {
        return ""
    }
    return parts[1]
}

func (r *Router) signInPath() string {
    return "/login"
}

func isSafeNext(s string) bool {
    if s == "" {
        return false
    }
    if strings.Contains(s, "://") {
        return false
    }
    if !strings.HasPrefix(s, "/") {
        return false
    }
    if strings.HasPrefix(s, "//") {
        return false
    }
    return true
}
