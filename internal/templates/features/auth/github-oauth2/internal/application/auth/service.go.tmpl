package auth

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"sort"
	"time"

	"github.com/google/uuid"

	domainSession "{{ .ModulePath }}/internal/domain/session"
	domainUser "{{ .ModulePath }}/internal/domain/user"
)

type Service struct {
	users           UserRepository
	sessions        SessionRepository
	providers       map[string]OAuthProvider
	primaryProvider string
	clock           Clock
	sessionTTL      time.Duration
}

type UUIDV7Generator struct{}

func (UUIDV7Generator) New() (string, error) {
	id, err := uuid.NewV7()
	if err != nil {
		return "", err
	}
	return id.String(), nil
}

func NewService(users UserRepository, sessions SessionRepository, providers []OAuthProvider, clock Clock, sessionTTL time.Duration) *Service {
	providerMap := make(map[string]OAuthProvider, len(providers))
	var primary string
	for _, p := range providers {
		if p == nil {
			continue
		}
		if _, exists := providerMap[p.ID()]; !exists {
			providerMap[p.ID()] = p
		}
		if primary == "" {
			primary = p.ID()
		}
	}
	return &Service{users: users, sessions: sessions, providers: providerMap, primaryProvider: primary, clock: clock, sessionTTL: sessionTTL}
}

func randomToken(n int) string {
	b := make([]byte, n)
	_, _ = rand.Read(b)
	return hex.EncodeToString(b)
}

// StartOAuth generates state and returns provider redirect URL.
func (s *Service) StartOAuth(ctx context.Context, req StartOAuthRequest) (StartOAuthResponse, error) {
	_ = ctx
	resp := StartOAuthResponse{}
	p, ok := s.providers[req.Provider]
	if !ok {
		return resp, fmt.Errorf("unknown oauth provider: %s", req.Provider)
	}
	resp.State = randomToken(16)
	resp.RedirectURL = p.AuthCodeURL(resp.State)
	return resp, nil
}

// HandleCallback completes provider flow, links identity, and creates a session.
func (s *Service) HandleCallback(ctx context.Context, req HandleCallbackRequest) (HandleCallbackResponse, error) {
	resp := HandleCallbackResponse{}
	if req.State == "" || req.State != req.CookieState {
		return resp, fmt.Errorf("invalid oauth state")
	}
	p, ok := s.providers[req.Provider]
	if !ok {
		return resp, fmt.Errorf("unknown oauth provider: %s", req.Provider)
	}
	token, err := p.Exchange(ctx, req.Code)
	if err != nil {
		return resp, fmt.Errorf("exchange code: %w", err)
	}
	profile, err := p.FetchProfile(ctx, token)
	if err != nil {
		return resp, fmt.Errorf("fetch profile: %w", err)
	}
	if profile.Provider == "" {
		profile.Provider = p.ID()
	}
	if profile.Subject == "" {
		return resp, fmt.Errorf("provider %s returned empty subject", p.ID())
	}

	idGen := UUIDV7Generator{}

	candidate, err := domainUser.New(idGen, s.clock, profile.Name, profile.Email, profile.AvatarURL, profile.Provider, profile.Subject)
	if err != nil {
		return resp, fmt.Errorf("create user: %w", err)
	}

	sess, err := domainSession.New(idGen, s.clock, s.sessionTTL, candidate.ID, req.UserAgent, req.ClientIP)
	if err != nil {
		return resp, fmt.Errorf("create session: %w", err)
	}

	user, createdSession, err := s.users.EnsureUserWithIdentityAndCreateSession(ctx, candidate, profile.Provider, profile.Subject, sess)
	if err != nil {
		return resp, fmt.Errorf("ensure user: %w", err)
	}

	resp.User = toUserDTO(user)
	resp.Session = toSessionDTO(createdSession)
	return resp, nil
}

// CurrentUser resolves user by session id and touches session.
func (s *Service) CurrentUser(ctx context.Context, req CurrentUserRequest) (CurrentUserResponse, error) {
	resp := CurrentUserResponse{}
	if req.SessionID == "" {
		return resp, nil
	}
	sess, err := s.sessions.FindByID(ctx, req.SessionID)
	if err != nil || sess == nil {
		return resp, err
	}
	now := s.clock.Now()
	if sess.IsExpired(now) {
		return resp, nil
	}
	_ = s.sessions.Touch(ctx, req.SessionID, now)
	user, err := s.users.FindByID(ctx, sess.UserID)
	if err != nil || user == nil {
		return resp, err
	}
	resp.User = toUserDTO(user)
	return resp, nil
}

// Logout revokes the session.
func (s *Service) Logout(ctx context.Context, req LogoutRequest) (LogoutResponse, error) {
	resp := LogoutResponse{}
	if req.SessionID == "" {
		return resp, nil
	}
	if err := s.sessions.Revoke(ctx, req.SessionID, s.clock.Now()); err != nil {
		return resp, err
	}
	resp.Revoked = true
	return resp, nil
}

// ProviderIDs returns all configured OAuth provider identifiers.
func (s *Service) ProviderIDs() ProviderIDsResponse {
	ids := make([]string, 0, len(s.providers))
	for id := range s.providers {
		ids = append(ids, id)
	}
	sort.Strings(ids)
	return ProviderIDsResponse{IDs: ids}
}

// PrimaryProvider returns the first registered provider identifier.
func (s *Service) PrimaryProvider() PrimaryProviderResponse {
	return PrimaryProviderResponse{ID: s.primaryProvider}
}

func toUserDTO(user *domainUser.User) *UserDTO {
	if user == nil {
		return nil
	}
	return &UserDTO{
		ID:        user.ID,
		Email:     user.Email,
		Name:      user.Name,
		AvatarURL: user.AvatarURL,
		CreatedAt: user.CreatedAt,
	}
}

func toSessionDTO(sess *domainSession.Session) *SessionDTO {
	if sess == nil {
		return nil
	}
	var revokedAt *time.Time
	if sess.RevokedAt != nil {
		t := *sess.RevokedAt
		revokedAt = &t
	}
	return &SessionDTO{
		ID:         sess.ID,
		UserID:     sess.UserID,
		CreatedAt:  sess.CreatedAt,
		ExpiresAt:  sess.ExpiresAt,
		LastSeenAt: sess.LastSeenAt,
		UserAgent:  sess.UserAgent,
		ClientIP:   sess.ClientIP,
		RevokedAt:  revokedAt,
	}
}

type SystemClock struct{}

func (SystemClock) Now() time.Time { return time.Now() }
