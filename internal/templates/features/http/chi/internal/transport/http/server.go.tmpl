package http

import (
    "context"
    "log/slog"
    "net/http"
    "time"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/justinas/nosurf"
)

// Config controls the HTTP server bootstrap.
type Config struct {
    Addr string
}

type Server struct {
    cfg        Config
    router     *Router
    httpServer *http.Server
}

// NewServer constructs a chi-based HTTP server.
func NewServer(cfg Config) *Server {
    if cfg.Addr == "" {
        cfg.Addr = ":3333"
    }

    chiRouter := chi.NewRouter()
    
    // Add some useful middleware
    chiRouter.Use(middleware.Logger)
    chiRouter.Use(middleware.Recoverer)
    // CSRF protection for all POST/PUT/PATCH/DELETE requests.
    chiRouter.Use(func(next http.Handler) http.Handler {
        csrf := nosurf.New(next)
        // Align cookie name with templates/scripts expecting 'csrf_token'
        csrf.SetBaseCookie(http.Cookie{
            Name:     "csrf_token",
            Path:     "/",
            HttpOnly: false, // allow JS to read for HTMX/header injection
            SameSite: http.SameSiteLaxMode,
        })
        return csrf
    })
    
    router := NewRouter()
    {{- if .Stack.HasFeature "auth-github-oauth2" }}
    chiRouter.Use(router.AuthMiddleware)
    {{- end }}
    router.Mount(chiRouter)

    staticHandler := http.FileServer(http.Dir("public"))
    chiRouter.NotFound(func(w http.ResponseWriter, req *http.Request) {
        staticHandler.ServeHTTP(w, req)
    })

    srv := &http.Server{
        Addr:    cfg.Addr,
        Handler: chiRouter,
    }

    return &Server{cfg: cfg, router: router, httpServer: srv}
}

// Listen starts the chi server and handles graceful shutdown.
func (s *Server) Listen(ctx context.Context) error {
    errCh := make(chan error, 1)

    go func() {
        slog.Info("Serving {{ .AppName }} with chi", "addr", s.cfg.Addr)
        if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            errCh <- err
        }
        close(errCh)
    }()

    select {
    case <-ctx.Done():
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
            return err
        }
        if err, ok := <-errCh; ok {
            return err
        }
        return nil
    case err, ok := <-errCh:
        if !ok {
            return nil
        }
        return err
    }
}

// Router exposes the configured router instance.
func (s *Server) Router() *Router {
    return s.router
}
