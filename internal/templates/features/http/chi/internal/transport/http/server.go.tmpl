package http

import (
    "context"
    "fmt"
    "net/http"
    "time"

    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
)

// Config controls the HTTP server bootstrap.
type Config struct {
    Addr string
}

type Server struct {
    cfg        Config
    router     *Router
    httpServer *http.Server
}

// NewServer constructs a chi-based HTTP server.
func NewServer(cfg Config) *Server {
    if cfg.Addr == "" {
        cfg.Addr = ":3333"
    }

    chiRouter := chi.NewRouter()
    
    // Add some useful middleware
    chiRouter.Use(middleware.Logger)
    chiRouter.Use(middleware.Recoverer)
    
    router := NewRouter()
    router.Mount(chiRouter)

    staticHandler := http.FileServer(http.Dir("public"))
    chiRouter.NotFound(func(w http.ResponseWriter, req *http.Request) {
        staticHandler.ServeHTTP(w, req)
    })

    srv := &http.Server{
        Addr:    cfg.Addr,
        Handler: chiRouter,
    }

    return &Server{cfg: cfg, router: router, httpServer: srv}
}

// Listen starts the chi server and handles graceful shutdown.
func (s *Server) Listen(ctx context.Context) error {
    errCh := make(chan error, 1)

    go func() {
        fmt.Printf("Serving {{ .AppName }} with chi on %s\n", s.cfg.Addr)
        if err := s.httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            errCh <- err
        }
        close(errCh)
    }()

    select {
    case <-ctx.Done():
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := s.httpServer.Shutdown(shutdownCtx); err != nil {
            return err
        }
        if err, ok := <-errCh; ok {
            return err
        }
        return nil
    case err, ok := <-errCh:
        if !ok {
            return nil
        }
        return err
    }
}

// Router exposes the configured router instance.
func (s *Server) Router() *Router {
    return s.router
}
