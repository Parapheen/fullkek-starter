package http

import (
    "context"
    "log/slog"
    "net/http"
    "time"

    "github.com/justinas/nosurf"
)

// Config controls the HTTP server bootstrap.
type Config struct {
    Addr string
}

type Server struct {
    cfg    Config
    router *Router
    server *http.Server
}

// NewServer constructs a net/http server with a ServeMux that serves HTML content.
func NewServer(cfg Config) *Server {
    if cfg.Addr == "" {
        cfg.Addr = ":3333"
    }

    router := NewRouter()
    mux := http.NewServeMux()
    router.Register(mux)

    staticDir := http.Dir("public")
    staticHandler := http.FileServer(staticDir)

    var handler http.Handler = http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
        if req.URL.Path != "/" {
            if file, err := staticDir.Open(req.URL.Path); err == nil {
                _ = file.Close()
                staticHandler.ServeHTTP(w, req)
                return
            }
        }
        mux.ServeHTTP(w, req)
    })

    // Wrap with CSRF protection first so downstream handlers see verified requests.
    csrf := nosurf.New(handler)
    csrf.SetBaseCookie(http.Cookie{
        Name:     "csrf_token",
        Path:     "/",
        HttpOnly: false,
        SameSite: http.SameSiteLaxMode,
    })
    handler = csrf

    {{- if .Stack.HasFeature "auth-github-oauth2" }}
    handler = router.AuthMiddleware(handler)
    {{- end }}

    srv := &http.Server{
        Addr:    cfg.Addr,
        Handler: handler,
    }

    return &Server{cfg: cfg, router: router, server: srv}
}

// Listen blocks until the server stops or the context is cancelled.
func (s *Server) Listen(ctx context.Context) error {
    errCh := make(chan error, 1)

    go func() {
        slog.Info("Serving {{ .AppName }} via net/http", "addr", s.cfg.Addr)
        if err := s.server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            errCh <- err
        }
        close(errCh)
    }()

    select {
    case <-ctx.Done():
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := s.server.Shutdown(shutdownCtx); err != nil {
            return err
        }
        if err, ok := <-errCh; ok {
            return err
        }
        return nil
    case err, ok := <-errCh:
        if !ok {
            return nil
        }
        return err
    }
}

// Router exposes the configured router instance.
func (s *Server) Router() *Router {
    return s.router
}
